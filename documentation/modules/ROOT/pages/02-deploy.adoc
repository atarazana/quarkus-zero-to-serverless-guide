= Deploying the Atomic Fruit Service
include::_attributes.adoc[]

This is a sample Fruit service built from a maven artifact that generates all the needed Java scaffold for a Quarkus Maven app.

[#generate-the-quarkus-app-scaffold-using-a-maven-archetype]
== Generate the Quarkus app scaffold using a maven archetype

By default, the command will target the latest version of `quarkus-universe-bom` (unless specific coordinates have been specified). If you run offline however, it will look for the latest locally available and if `quarkus-universe-bom` (satisfying the default version range which is currently up to 2.0) is not available locally, it will fallback to the bundled platform based on `quarkus-bom` (the version will match the version of the plugin).

[.console-input]
[source,sh,role="copypaste"]
----
mvn io.quarkus:quarkus-maven-plugin:$QUARKUS_VERSION:create \
  -DprojectGroupId="com.redhat.atomic.fruit" \
  -DprojectArtifactId="atomic-fruit-service" \
  -DprojectVersion="1.0-SNAPSHOT" \
  -DclassName="FruitResource" \
  -Dpath="fruit"
----

****
If you decide to generate a REST resource (using the `className` attribute), the endpoint is exposed at: http://localhost:8080/$path. If you use the default `path`, the URL is: http://localhost:8080/hello.

The project is generated in a directory named after the passed artifactId. If the directory already exists, the generation fails.

A pair of Dockerfiles for native and jvm mode are also generated in `src/main/docker`. Instructions to build the image and run the container are written in those Dockerfiles.
****

[#testing-different-ways-of-packaging-the-app]
== Testing different ways of packaging the app

NOTE: At this point you must be compliant with all the prerequisites describes in the xref:01-setup.adoc[setup section] and be inside the app dir as indicated.

[#jvm-mode]
=== JVM mode

This mode generates a Quarkus Java jar file.

. Generate `jar`
+
[.console-input]
[source,sh,role="copypaste"]
----
./mvnw -DskipTests clean package
----

. Run the application in JVM mode.
+
[.console-input]
[source,sh,role="copypaste"]
----
java -jar ./target/atomic-fruit-service-1.0-SNAPSHOT-runner.jar <1>
----

. Test from another terminal or a browser, you should receive a `hello` string.
+
[.console-input]
[source,sh,role="copypaste"]
----
curl http://localhost:8080/fruit
----

<1> *_Ctrl+C_ to stop.*

[#native-mode-i]
=== Native Mode I

This mode generates a Quarkus native binary file.

[NOTE]
====
This is huge... now you have a native binary file, no JVM involved.
====

. Generate the binary
+
[.console-input]
[source,sh,role="copypaste"]
----
./mvnw -DskipTests clean package -Pnative
----

. Run the application in native mode.
+
[.console-input]
[source,sh,role="copypaste"]
----
./target/atomic-fruit-service-1.0-SNAPSHOT-runner <1>
----

. Test from another terminal or a browser, you should receive a `hello` string.
+
[.console-input]
[source,sh,role="copypaste"]
----
curl http://localhost:8080/fruit
----

<1> *_Ctrl+C_ to stop.*

[#native-mode-ii-generated-in-a-container]
=== Native Mode II (generated in a container)

Native executables make Quarkus applications ideal for containers and serverless workloads.
This mode generates a Quarkus native binary file using a build image and builds an image with it.

.If you want to use Mandrel
****
[.console-input]
[source,sh]
----
./mvnw package -Pnative -Dquarkus.native.container-build=true -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:{mandrel-flavor}
----
****


. Create the docker image:
+
[.console-input]
[source,sh,role="copypaste"]
----
./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true
docker build -f src/main/docker/Dockerfile.native -t atomic-fruit-service:1.0-SNAPSHOT .
----
+
[NOTE]
====
If you want/need to set the container runtime you can use `-Dquarkus.native.container-runtime=(podman/docker)`. For instance to use `podman` (then use `podman` to build the image, etc.):

[source,sh]
----
./mvnw package -DskipTests -Pnative -Dquarkus.native.container-build=true -Dquarkus.native.container-runtime=podman
----
====

. Run the image created.
+
[.console-input]
[source,sh,role="copypaste"]
----
docker run -i --rm -p 8080:8080 atomic-fruit-service:1.0-SNAPSHOT <1>
----

. Test from another terminal or a browser, you should receive a `hello` string.
+
[.console-input]
[source,sh,role="copypaste"]
----
curl http://localhost:8080/fruit
----

<1> *_Ctrl+C_ to stop.*

.Push to a image registry
****

[TIP]
====
Finally you could push it to the image registry of your choice.

[source,sh]
----
docker tag atomic-fruit-service:1.0-SNAPSHOT quay.io/<registry_user>/atomic-fruit-service:1.0-SNAPSHOT
docker push quay.io/<registry_user>/atomic-fruit-service:1.0-SNAPSHOT
----
====
****

[#running-in-development-mode-and-enjoy-hot-reloading]
== Running in development mode and enjoy hot reloading

We can run our app in development mode, to do so we have to do as follows:

[.console-input]
[source,sh,role="copypaste"]
----
./mvnw quarkus:dev
----

.`quarkus:dev`
****
Enables hot deployment with background compilation, which means that when you modify your Java files or your resource files and refresh your browser these changes will automatically take effect. This works too for resource files like the configuration property file. The act of refreshing the browser triggers a scan of the workspace, and if any changes are detected the Java files are compiled, and the application is redeployed, then your request is serviced by the redeployed application. If there are any issues with compilation or deployment an error page will let you know.
****

As we have done several times before, from a different terminal or using a browser try this url: http://localhost:8080/fruit

Now, without stopping our application, let\'s add some logging...

[#adding-log-capabilities]
=== Adding log capabilities

Internally Quarkus uses JBoss Logging; you can also use it inside your application so that no other dependencies should be added for your logs.

[NOTE]
====
You can configure Quarkus logging by setting the following parameters to `$PROJECT_HOME/src/main/resources/application.properties`:

[source,properties]
----
## Enable logging
quarkus.log.console.enable=true
quarkus.log.console.level=DEBUG

## Log level settings
quarkus.log.category."com.redhat.atomic".level=DEBUG
----
====

. Update `$PROJECT_HOME/src/main/java/com/redhat/atomic/fruit/FruitResource.java` with the relevant lines bellow.
+
[source,java,role="copypaste"]
----
...

  @GET
  @Produces(MediaType.TEXT_PLAIN)
  public String hello() {
      logger.debug("Hello method is called"); // logging
      return "hello";
  }

...
----

. From a different terminal or using a browser try/reload this url: http://localhost:8080/fruit

The console log handler is enabled by default. It outputs all log events to the console of your application (typically to the systemâ€™s `stdout`).

For details of its configuration options, see https://quarkus.io/guides/logging#quarkus-log-logging-log-config_quarkus.log.console[the Console Logging configuration reference].

[#adding-custom-properties]
=== Adding custom properties

Quarkus uses https://microprofile.io/project/eclipse/microprofile-config[MicroProfile Config] annotations to inject the configuration properties in the application.

. Add the following and update the `hello`() method to use your custom property.
+
[source,java,role="copypaste"]
----
...

  @ConfigProperty(name = "hello.message")
  String message;
  
  @GET
  @Produces(MediaType.TEXT_PLAIN)
  public String hello() {
      logger.debug("Hello method is called with message: " + this.message); // logging & custom property
      return message; // custom property
  }

...
----

. Add the following property to your application.properties.
+
[source,properties,role="copypaste"]
----
## custom properties
hello.message = ${HELLO_MESSAGE:hello}
----

. From a different terminal or using a browser try/reload this url: http://localhost:8080/fruit

. Now, without stopping our application, change the value of `hello.message` from hello to something different. Save the aplication.propertlies file and try again. This time the result should be different.

WARNING: Return the value of `hello.message` back to `hello` and stop the app with _Ctrl+C_