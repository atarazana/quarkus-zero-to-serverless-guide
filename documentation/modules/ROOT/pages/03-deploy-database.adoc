
= Adding a Data Base to our application
include::_attributes.adoc[]
:project_name: %USERNAME%-{artifact_id}

[#deploying-postgresql]
== Deploying PostgreSQL

WARNING: Before proceeding you must be logged in to the OpenShift cluster. If you're not, log in your cluster using `oc login` with a normal user (no need for special permissions).

We\'re going to deploy PostgreSQL using a template, in general an operator is a better choice but for the sake of simplicity in this demo a template is a good choice.

. Using `oc`
+
[.console-input]
[source,sh,subs="attributes+",role="copypaste"]
----
export PROJECT_NAME={project_name}
oc new-project $\{PROJECT_NAME}
oc new-app -e POSTGRESQL_USER=luke -e POSTGRESQL_PASSWORD=secret -e POSTGRESQL_DATABASE=my_data centos/postgresql-10-centos7 --name=my-database -n $\{PROJECT_NAME}
----

. Some labeling specially useful for OpenShift developer view.
+
[.console-input]
[source,sh,subs="attributes+",role="copypaste"]
----
oc label deployment/my-database app.openshift.io/runtime=postgresql --overwrite -n $\{PROJECT_NAME} && \
oc label deployment/my-database app.kubernetes.io/part-of={APP_NAME} --overwrite -n $\{PROJECT_NAME}
----

[#adding-db-related-extensions]
== Adding DB related extensions

We need some extensions to expose our database to the world: REST JSON, PostgreSQL and Panache Hibernate as our ORM.

[.console-input]
[source,sh,role="copypaste"]
----
./mvnw quarkus:add-extension -Dextension="quarkus-resteasy-jsonb, quarkus-jdbc-postgresql, quarkus-hibernate-orm-panache"
----

You should see something like this when you add succesfully extensions to an app.

[.console-output]
[source,console]
----
...
[INFO] --- quarkus-maven-plugin:0.23.1:add-extension (default-cli) @ atomic-fruit-service ---
✅ Adding extension io.quarkus:quarkus-resteasy-jsonb
✅ Adding extension io.quarkus:quarkus-jdbc-postgresql
✅ Adding extension io.quarkus:quarkus-hibernate-orm-panache
...
----

[#exposing-rest-endpoints-for-crud-operations]
== Exposing REST endpoints for CRUD operations

While the code is surprisingly simple, under the hood this is using:

* **RESTEasy** to expose the REST endpoints
* **Hibernate** ORM with Panache to perform the CRUD operations on the database
* **Maven** Java project structure

[#lets-create-the-fruit-entity]
=== Let\'s create the `Fruit` entity

Create this file here `$PROJECT_HOME/src/main/java/com/redhat/atomic/fruit/Fruit.java` and add the following content to it.

[source,java,role="copypaste"]
----
package com.redhat.atomic.fruit;

import java.util.List;

import javax.persistence.Entity;

import io.quarkus.hibernate.orm.panache.PanacheEntity;

@Entity
public class Fruit extends PanacheEntity {

    public String name;
    public String season;

    public static List<Fruit> getAllFruitsForSeason(String season) {
        return find("season", season).list();
    }
}
----

As you can see our `Fruit` class extends `PanacheEntity` which adds the default *CRUD* methods you can expects from an *ORM framework* such as **Panache**. How ever it doesn\'t add any custom methods. In this case we want to be able to search by season and that\'s the reason we have added a methos called `getAllFruitsForSeason`.

[#lets-crudify-our-rest-enabled-service]
=== Let\'s CRUDify our REST enabled service

What we want to do is easy:

* Return all the fruit if *GET* `/fruit`
* Save a Fruit if *POST* `/fruit`
* Search fruit if a given season if *GET* `/fruit/\{season}`

[source,java,role="copypaste"]
----
package com.redhat.atomic.fruit;

import java.net.URI;
import java.util.List;

import javax.transaction.Transactional;
import javax.ws.rs.Consumes;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriBuilder;

import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.jboss.logging.Logger;

@Path("/fruit")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class FruitResource {
    Logger logger = Logger.getLogger(FruitResource.class);

    @ConfigProperty(name = "hello.message")
    String message;
    
    @GET
    @Path("hello")
    @Produces(MediaType.TEXT_PLAIN)
    public String hello() {
        logger.debug("Hello method is called with message: " + this.message); // logging & custom property
        return message; // custom property
    }
    
    @GET
    public List<Fruit> allFruits() {
        return Fruit.listAll(); 
    }

    @GET
    @Path("{season}")
    public List<Fruit> fruitsBySeason(@PathParam("season") String season) {
        return Fruit.getAllFruitsForSeason(season);
    }

    @POST
    @Transactional
    public Response saveFruit(Fruit fruit) {
        // since the FruitEntity is a panache entity
        // persist is available by default
        fruit.persist();
        final URI createdUri = UriBuilder.fromResource(FruitResource.class)
                        .path(Long.toString(fruit.id))
                        .build();
        return Response.created(createdUri).build();
    }
}
----

We need to adapt the test class after the changes to `FruitResource`. Update `$PROJECT_HOME/src/test/java/com/redhat/atomic/fruit/FruitResourceTest.java` with the next code.

[source,java,role="copypaste"]
----
package com.redhat.atomic.fruit;

import io.quarkus.test.junit.QuarkusTest;
import org.junit.jupiter.api.Test;

import static io.restassured.RestAssured.given;
import static org.hamcrest.CoreMatchers.is;

@QuarkusTest
public class FruitResourceTest {

    @Test
    public void testHelloEndpoint() {
        given()
          .when().get("/fruit/hello")
          .then()
             .statusCode(200)
             .body(is("hello"));
    }

}
----

[#adding-datasource-related-properties]
=== Adding datasource related properties

Add the following properties to your `./src/main/resources/application.properties` file:

NOTE: As you can see we have three different jdbc urls for three execution profiles (`dev`, `prod` the default and `che` a custom profile we\'ll use later)

[source,properties,role="copypaste"]
----
## Data Base related properties
quarkus.datasource.jdbc.url = jdbc:postgresql://my-database:5432/my_data
quarkus.datasource.db-kind=postgresql

%dev.quarkus.datasource.jdbc.url = jdbc:postgresql://localhost:5432/my_data
%dev.quarkus.datasource.db-kind=postgresql
#%dev.quarkus.datasource.jdbc.url = jdbc:h2:mem:myDB
#%dev.quarkus.datasource.db-kind=h2
#%dev.quarkus.datasource.username = username-default
#%test.quarkus.datasource.jdbc.url = jdbc:h2:mem:myDB
#%test.quarkus.datasource.db-kind=h2
#%test.quarkus.datasource.username = username-default

quarkus.datasource.username = luke
quarkus.datasource.password = secret

## drop and create the database at startup (use `update` to only update the schema)
%dev.quarkus.hibernate-orm.database.generation = drop-and-create
quarkus.hibernate-orm.database.generation = create
quarkus.hibernate-orm.sql-load-script = import.sql
## show sql statements in log
quarkus.hibernate-orm.log.sql = true
----

[#testing-locally]
== Testing locally

[#adding-some-fruits]
=== Adding some fruits

Create a file called `import.sql` here `./src/main/resources`

This is a suitable content for that file.

[source,sql,role="copypaste"]
----
INSERT INTO Fruit(id,name,season) VALUES ( nextval ('hibernate_sequence') , 'Mango'      , 'Spring' );
INSERT INTO Fruit(id,name,season) VALUES ( nextval ('hibernate_sequence') , 'Strawberry' , 'Spring' );
INSERT INTO Fruit(id,name,season) VALUES ( nextval ('hibernate_sequence') , 'Orange'     , 'Winter' );
INSERT INTO Fruit(id,name,season) VALUES ( nextval ('hibernate_sequence') , 'GrapeFruit' , 'Winter' );
INSERT INTO Fruit(id,name,season) VALUES ( nextval ('hibernate_sequence') , 'Blueberry'  , 'Summer' );
INSERT INTO Fruit(id,name,season) VALUES ( nextval ('hibernate_sequence') , 'Banana'     , 'Summer' );
INSERT INTO Fruit(id,name,season) VALUES ( nextval ('hibernate_sequence') , 'Plum'       , 'Summer' );
INSERT INTO Fruit(id,name,season) VALUES ( nextval ('hibernate_sequence') , 'Apple'      , 'Fall'   );
INSERT INTO Fruit(id,name,season) VALUES ( nextval ('hibernate_sequence') , 'Grape '     , 'Fall'   );
----

[#testing-locally-using-port-forwarding]
=== Using port-forwarding

In a different terminal...

NOTE: Load environment as we did before `. ./env.sh` or just substitute `PROJECT_NAME` accordingly 

IMPORTANT: If using `oc` you may want to set the default project to $\{PROJECT_NAME}: `oc project ${PROJECT_NAME}`

[.console-input]
[source,sh,role="copypaste"]
----
POD_NAME=$(oc get pod -n ${PROJECT_NAME} -o jsonpath='{.items[0].metadata.name}')
oc port-forward ${POD_NAME} 5432:5432 -n ${PROJECT_NAME} 
----

In your current terminal run your code using profile `dev`

:NOTE: When you run you\'re app in `dev` mode `dev` profile is activated by default.

IMPORTANT: Later we\'ll need to run `che`, we\'ll do it by adding: `-Dquarkus.profile=che`

[.console-input]
[source,sh,role="copypaste"]
----
./mvnw compile quarkus:dev
----

If you use another terminal and try this url: http://localhost:8080/fruit this time you should get a list of fruits.

[.console-input]
[source,sh,role="copypaste"]
----
curl http://localhost:8080/fruit
[{"id":1,"name":"Mango","season":"Spring"},{"id":2,"name":"Strawberry","season":"Spring"},{"id":3,"name":"Orange","season":"Winter"},{"id":4,"name":"GrapeFruit","season":"Winter"},{"id":5,"name":"Blueberry","season":"Summer"},{"id":6,"name":"Banana","season":"Summer"},{"id":7,"name":"Plum","season":"Summer"},{"id":8,"name":"Apple","season":"Fall"},{"id":9,"name":"Grape ","season":"Fall"}]
----

We\'re done with the PostgreSQL tests, now go to the terminal window where we forwaded the database port and stop it with Ctrl+C

Leave the application running we\'re going to do some more changes.

[#little-diversion-using-h2]
=== Little diversion: Using H2

What if you wanted to use H2, the embedded database when in `dev` mode?

**Adding H2**

We will use _Quarkus_ extension to add **H2 JDBC Driver**. Go back to the terminal and run the following maven plugin:

[.console-input]
[source,sh,role="copypaste"]
----
./mvnw quarkus:add-extension -Dextension="io.quarkus:quarkus-jdbc-h2"
----

The output should looks like the following:

[.console-output]
[source,console]
----
[INFO] Scanning for projects...
[INFO] 
[INFO] ------------< com.redhat.atomic.fruit:atomic-fruit-service >------------
[INFO] Building atomic-fruit-service 1.0-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
[INFO] 
[INFO] --- quarkus-maven-plugin:0.23.1:add-extension (default-cli) @ atomic-fruit-service ---
✅ Adding dependency io.quarkus:quarkus-jdbc-h2:jar
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  1.606 s
[INFO] Finished at: 2019-10-13T15:37:52+02:00
[INFO] ------------------------------------------------------------------------
----

Second, change some datasource related properties in `application.properties`

NOTE: we have changed the value of `dev.quarkus.datasource.url` now the url points to H2 instead of PostgreSQL, so no need to port-forward our DB running in our cluster.

[source,properties,role="copypaste"]
----
#%dev.quarkus.datasource.jdbc.url = jdbc:postgresql://localhost:5432/my_data
#%dev.quarkus.datasource.db-kind=postgresql
%dev.quarkus.datasource.jdbc.url = jdbc:h2:mem:myDB
%dev.quarkus.datasource.db-kind=h2
%dev.quarkus.datasource.username = username-default
%test.quarkus.datasource.jdbc.url = jdbc:h2:mem:myDB
%test.quarkus.datasource.db-kind=h2
%test.quarkus.datasource.username = username-default
----

If, accidentally, you stopped the application you can run it again using profile `dev` running the next command. However this time the application will run queries against H2.

[.console-input]
[source,sh,role="copypaste"]
----
./mvnw compile quarkus:dev
----

As we have done before, from another terminal run:

[.console-input]
[source,sh,role="copypaste"]
----
curl http://localhost:8080/fruit
[{"id":1,"name":"Mango","season":"Spring"},{"id":2,"name":"Strawberry","season":"Spring"},{"id":3,"name":"Orange","season":"Winter"},{"id":4,"name":"GrapeFruit","season":"Winter"},{"id":5,"name":"Blueberry","season":"Summer"},{"id":6,"name":"Banana","season":"Summer"},{"id":7,"name":"Plum","season":"Summer"},{"id":8,"name":"Apple","season":"Fall"},{"id":9,"name":"Grape ","season":"Fall"}]
----

[#test-creating-a-fruit]
=== Test creating a fruit

Let\'s try to create a Fruit object in our database.

[.console-input]
[source,sh,role="copypaste"]
----
curl -vvv -d '{"name": "Banana", "season": "Summer"}' -H "Content-Type: application/json" POST http://localhost:8080/fruit
----

And the output ...

[.console-output]
[source,console]
----
* Rebuilt URL to: POST/
* Could not resolve host: POST
* Closing connection 0
curl: (6) Could not resolve host: POST
*   Trying ::1...
* TCP_NODELAY set
* Connected to localhost (::1) port 8080 (#1)
> POST /fruit HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.54.0
> Accept: */*
> Content-Type: application/json
> Content-Length: 38
> 
* upload completely sent off: 38 out of 38 bytes
< HTTP/1.1 201 Created
< Location: http://localhost:8080/fruit/1
< Content-Length: 0
< 
* Connection #1 to host localhost left intact
----

[#adding-swagger-ui-to-ease-api-development-and-testing]
=== Adding Swagger UI to ease API development and testing

You can easily generate en OpenAPI compliant description of your API and at additionally add a Swagger UI to your app by adding the `openapi` extension. Please run this command to do so.

[.console-input]
[source,sh,role="copypaste"]
----
./mvnw quarkus:add-extension -Dextensions="quarkus-smallrye-openapi"
----

Try opening this url http://localhost:8080/swagger-ui with a browser you should see something like:

image::swagger-ui.png[Swagger UI]

[#try-creating-another-fruit-this-time-with-the-swagger-ui]
=== Try creating another Fruit this time with the Swagger UI

Try to create a new fruit, get all and get by season.

Click on *POST /fruit* then click on *Try it out*


WARNING: Don\'t forget to delete the `id` property when creating a new fruit because `id` is self-generated.


image::create-fruit-1.png[Create Fruit 1]

Now click on *Execute* eventually you should get a result similar to this one.

NOTE: Pay attention to **Code**, it should be **201**.

image::create-fruit-2.png[Create Fruit 1]

[#adding-health-checks]
== Adding health checks

Health checks is one of those things that if recommendable in general is a must for every Cloud Native App and in quarkus it\'s a extension so let\'s add it.

[.console-input]
[source,sh,role="copypaste"]
----
./mvnw quarkus:add-extension -Dextension="smallrye-health"
----

Make sure your application is running in `dev` mode, then test the `/health` endpoint like this:

[.console-input]
[source,sh,role="copypaste"]
----
curl http://localhost:8080/health
----

You should see something similar to the following output:

[.console-output]
[source,console]
----
{
    "status": "UP",
    "checks": [
        {
            "name": "Database connections health check",
            "status": "UP"
        }
    ]
}
----

Ctrl+C

[#deploying-to-openshift]
== Deploying to OpenShift

First of all let\'s add the extension to deploy to OpenShift.

[.console-input]
[source,sh,role="copypaste"]
----
./mvnw quarkus:add-extension -Dextension="openshift"
----

Second let\'s remove the docker extension, we don\'t need it and they collide with each other.

[.console-input]
[source,sh,role="copypaste"]
----
./mvnw quarkus:remove-extension -Dextension="container-image-docker"
----

Add this couple of properties to `application.properties` so that we trust on the CA cert and set the namespace where we want to deploy our application.

[source,properties,role="copypaste"]
----
## Kubernetes Client
quarkus.kubernetes-client.trust-certs=true
quarkus.kubernetes-client.namespace=${PROJECT_NAME:atomic-fruit}

## Only generate OpenShift descriptors
quarkus.kubernetes.deployment-target=openshift

## Expose the service when deployed
quarkus.openshift.expose=true
----

Now we don\'t want to create the image locally, we want OpenShift build it using S2I, hence we shouldn\'t set the image group or registry, right? Find the next properties and comment them.

[source,properties]
----
## OCI Image
#quarkus.container-image.registry=<registry>
#quarkus.container-image.group=<registry_user>
----

Let\'s add a some additional labels `part-of` and `name`, and a custom label:

[source,properties,role="copypaste"]
----
## Recommended labels and a custom label for kubernetes and openshift
quarkus.openshift.part-of=fruits-app
quarkus.openshift.name=atomic-fruit-service
quarkus.openshift.labels.department=fruity-dept
----

Regarding annotations, out of the box, the generated resources will be annotated with version control related information that can be used either by tooling, or by the user for troubleshooting purposes.

[source,yaml]
----
annotations:
  app.quarkus.io/vcs-url: "<some url>"
  app.quarkus.io/commit-id: "<some git SHA>"
----

Let\'s add a custom annotation:

[source,properties,role="copypaste"]
----
## Custom annotations
quarkus.openshift.annotations."app.openshift.io/connects-to"=my-database
quarkus.openshift.annotations.foo=bar
quarkus.openshift.annotations."app.quarkus/id"=42
----

So far we haven\'t prepared the production profile, for instance we have no secret to keep the database credentials. Let\'s do something about it. Let\'s create a secret locally first.

NOTE: `openshift` extension takes the file we\'re generating and merge it with the one generated

[.console-input]
[source,sh,role="copypaste"]
----
mkdir -p ./src/main/kubernetes
cat <<EOF > ./src/main/kubernetes/openshift.yml
---
apiVersion: v1
kind: Secret
metadata:
  name: fruits-database-secret
stringData:
  user: luke
  password: secret
EOF
----

Now let\'s add the environment variables we need to connect to the database:

[source,properties,role="copypaste"]
----
## Environment variables
quarkus.openshift.env.mapping.db-username.from-secret=fruits-database-secret
quarkus.openshift.env.mapping.db-username.with-key=user
quarkus.openshift.env.mapping.db-password.from-secret=fruits-database-secret
quarkus.openshift.env.mapping.db-password.with-key=password
----

Let\'s package our application and have a look to the descriptors generated.

[.console-input]
[source,sh,role="copypaste"]
----
./mvnw clean package
----

Go to link:./target/kubernetes/openshift.yml[`./target/kubernetes/openshift.yml`] there you\'ll find: Service and Deployment...

Let\'s deploy the result.

[.console-input]
[source,sh,role="copypaste"]
----
./mvnw clean package -Dquarkus.kubernetes.deploy=true -DskipTests
----

Or

[.console-input]
[source,sh,role="copypaste"]
----
$ oc apply -n ${PROJECT_NAME} -f target/kubernetes/openshift.yml
----

Let\'s inspect the resources created.

[.console-input]
[source,sh,role="copypaste"]
----
$ oc get dc -n ${PROJECT_NAME}
----

[.console-output]
[source,console]
----
NAME                   READY   UP-TO-DATE   AVAILABLE   AGE
atomic-fruit-service   1/1     1            1           73s
my-database            1/1     1            1           89m
----

Now we can test that everything works properly.

[.console-input]
[source,sh,role="copypaste"]
----
curl http://$(oc get route atomic-fruit-service -o jsonpath='{.spec.host}')/fruit
----

What about native in this case? Easy, just add `-Dquarkus.native.container-build=true -Pnative`.

[.console-input]
[source,sh,role="copypaste"]
----
./mvnw clean package -Dquarkus.kubernetes.deploy=true -DskipTests -Dquarkus.native.container-build=true -Pnative
----